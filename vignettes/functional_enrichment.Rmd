<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{3. Automatic Functional Enrichment on Signature genes}
-->

Automatic Functional Enrichment on Signature genes
=============================================================

**Author**: Zuguang Gu ( z.gu@dkfz.de )

**Date**: `r Sys.Date()`

**Package version**: `r installed.packages()["cola", "Version"]`

-------------------------------------------------------------

```{r, echo = FALSE}
library(knitr)
knitr::opts_chunk$set(
    error = FALSE,
    tidy  = FALSE,
    message = FALSE)
```

If the matrix rows can correspond to genes (e.g. the gene expression matrix,
or the methylation array data where CpG sites can be annotated to the
transcription start site of genes), cola performs functional enrichment by
the `functional_enrichment()` function to the signatures by
[**ClusterProfiler**](https://bioconductor.org/packages/clusterProfiler/),
[**DOSE**](https://bioconductor.org/packages/DOSE/) or
[**ReactomePA**](https://bioconductor.org/packages/ReactomePA/) packages.

We first demonstrate the usage of `functional_enrichment()` function by the TCGA GBM dataset.
In following example code, `TCGA_GBM_subgroup.rds` is generated by the code
demonstrated [here](https://jokergoo.github.io/cola_examples/TCGA_GBM/) and we download
the result file that has already be generated.

```{r, results = "hide"}
download.file("https://jokergoo.github.io/cola_examples/TCGA_GBM/TCGA_GBM_subgroup.rds", 
    destfile = "TCGA_GBM_subgroup.rds", quiet = TRUE)
rl = readRDS("TCGA_GBM_subgroup.rds")
file.remove("TCGA_GBM_subgroup.rds")
```

We select result from a single method `ATC:skmeans`:

```{r}
library(cola)
res = rl["ATC:skmeans"]
res
```

We check how the signature genes looks like under 4-group classification:

```{r}
get_signatures(res, k = 4)
```

Rows are split into four groups with different expression patterns among samples. The functional
enrichment will be applied to genes in each row-cluster.

To apply functional enrichment, the important thing is to check the gene ID type in the input matrix.
The helper function `rownames()` directly returns the row names of the matrix stored in `res`.

```{r}
head(rownames(res))
```

The gene ID is symbol. For all enrichment analysis provided by **ClusterProfiler**, **DOSE** or **ReactomePA**,
the core ID type is Entrez ID, thus we need to convert from symbol to Entrez ID.

To make it easy, **cola** automatically tests the gene IDs types and it automatically recognizes three ID
types of Ensembl ID, RefSeq ID and gene symbol, which covers most cases of the analysis. If user's gene ID
type is one of the three supported ones, simply run `functional_enrichment()` on `res` only with specifying
the number of subgroups.

```{r, eval = FALSE}
lt = functional_enrichment(res, k = 4)
```

```{r, echo = FALSE}
if(file.exists("lt_functional_enrichment_TCGA_GBM.rds")) {
	lt = readRDS("lt_functional_enrichment_TCGA_GBM.rds")
} else {
	lt = functional_enrichment(res, k = 4)
	saveRDS(lt, "lt_functional_enrichment_TCGA_GBM.rds")
}
```

By default, `functional_enrichment()` runs enrichment on Gene Ontology, biological function ontologies.
`ontology` can be set as follows:

- `BP`/`MF`/`CC`, `org_db` argument should be set to the corresponding database, such as `"org.Hs.eg.db"`,
- `KEGG`, `organism` argument should be set to corresponding species abbreviation, such as `"hsa"`,
- `DO`, only works for human,
- `MSigDb`, only works for human, the path of gmt file is specified by `gmt_file` argument.,
- `Reactome`, `organism` argument should be set to the corresponding species, such as `"human"`.

`ontology` can be set as a vector of multiple ontologies.

The value of `lt` is a list of data frames for different ontologies combined with different k-means groups.

```{r}
names(lt)
head(lt[[1]])
```

If the gene ID type is not any of Ensembl ID, RefSeq ID or gene symbol, user needs to provide a named
vector which provides mapping between user's ID types to Entrez IDs.

In following example we demonstrate how to properly set the ID mapping by [the Golub leukemia dataset](https://jokergoo.github.io/cola_examples/Golub_leukemia/). The result file is already generated.

```{r, results = "hide"}
download.file("https://jokergoo.github.io/cola_examples/Golub_leukemia/Golub_leukemia_subgroup.rds", 
    destfile = "Golub_leukemia_subgroup.rds", quiet = TRUE)
rl = readRDS("Golub_leukemia_subgroup.rds")
file.remove("Golub_leukemia_subgroup.rds") 
```

To simplify, we only take result from on method:

```{r}
res = rl["ATC:skmeans"]
head(rownames(res))
```

The Golub leukemia dataset is a microarray dataset where the gene ID is the probe ID. Thankfully, 
there is already an annotation package from Bioconductor ([hu6800.db](https://bioconductor.org/packages/3.6/data/annotation/html/hu6800.db.html)) that provides mapping between the probe ID to Entrez ID.

```{r}
library(hu6800.db)
x = hu6800ENTREZID
mapped_probes = mappedkeys(x)
id_mapping = unlist(as.list(x[mapped_probes]))
head(id_mapping)
```

Proportion of probe IDs that can be mapped:

```{r}
sum(!is.na(id_mapping[rownames(res)]))/nrow(res)
```

As you see, the format of `id_mapping` is simple. Names of the vector are the probe IDs and the values are the Entrez IDs.
We can directly assign the ID mapping variable to `id_mapping` argument.

```{r, eval = FALSE}
lt = functional_enrichment(res, k = 3, id_mapping = id_mapping)
```

```{r, echo = FALSE}
if(file.exists("lt_functional_enrichment_Golub_leukemia.rds")) {
	lt = readRDS("lt_functional_enrichment_Golub_leukemia.rds")
} else {
	lt = functional_enrichment(res, k = 3, id_mapping = id_mapping)
	saveRDS(lt, "lt_functional_enrichment_Golub_leukemia.rds")
}
```

`functional_enrichment()` can also be applied to two other classes of objects:

- the `ConsensusPartitionList`, 
- simply a vector of gene IDs.


```{r}
sessionInfo()
```
