Cola Report for Hierarchical Partitioning
==================

**Date**: `r Sys.time()`, **cola version**: `r installed.packages()["cola", "Version"]`

----------------------------------------------------------------

<style type='text/css'>
<%
css = paste(readLines(paste0(TEMPLATE_DIR, "/custom.css")), collapse = "\n") -%>
<%= css %>
</style>

```{r, echo = FALSE, message = FALSE}
library(knitr)
library(markdown)
options(markdown.HTML.options = setdiff(c(getOption("markdown.HTML.options")), "base64_images"))
options(width = 120)
options(digits = 3)
opts_chunk$set(
	comment = "#>",
	fig.path = "figure_cola/",
	warning = FALSE,
	message = FALSE
)
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(genefilter))
```

<% res_hc = object -%>

## Summary

<% same_var_name = var_name == "res_hc" -%>

<% if(!same_var_name) { -%>

First the variable is renamed to `res_hc`.

```{r, eval = FALSE, echo = TRUE}
res_hc = <%=var_name%>
```
<% } -%>

```{r, echo = FALSE}
res_hc = object
```

All available functions which can be applied to `res_hc` object.

```{r}
res_hc
```

The call of `hierarchical_partition()` was:

```{r, echo = FALSE}
cat(paste(deparse(res_hc@call, width.cutoff = getOption("width")), collapse = "\n"), "\n")
```

Dimension of the input matrix:

```{r}
mat = get_matrix(res_hc)
dim(mat)
```

### Density distribution

The density distribution for each sample is visualized as one column in the following heatmap.
The clustering is based on the distance which is the Kolmogorov-Smirnov statistic between two distributions.

```{r, echo = FALSE, message = FALSE}
t1 = Sys.time()
message(qq("* making density heatmap of global distribution for each sample (@{ncol(mat)} samples)"), appendLF = FALSE)
```

```{r density-heatmap}
library(ComplexHeatmap)
<% if(is.null(get_anno(res_hc))) { -%>
densityHeatmap(mat, ylab = "value", cluster_columns = TRUE, show_column_names = FALSE)
<% } else { -%>
densityHeatmap(mat, top_annotation = HeatmapAnnotation(df = get_anno(res_hc), 
	col = get_anno_col(res_hc)), ylab = "value", cluster_columns = TRUE, show_column_names = FALSE)
<% } -%>
```

```{r, echo = FALSE, message = FALSE}
t2 = Sys.time(); message(paste0(", ", gsub("^ +", "", format(t2 - t1))))
```

About the hierarchy:

```{r}
max_depth(res_hc)
all_nodes(res_hc)
all_leaves(res_hc)
```

```{r, echo = FALSE, message = FALSE}
message(qq("* top rows are extracted by '@{res_hc[1]@top_value_method}' method"))
message(qq("* subgroups are detected by '@{res_hc[1]@partition_method}' method"))
```

### Guess best k

```{r, echo = FALSE, message = FALSE}
message("* guessing best k for each node")
```

Best `k` (number of partitions) for each node in the partition hierarchy:

```{r, eval = FALSE}
guess_best_k(res_hc)
```

```{r, echo = FALSE}
tb = guess_best_k(res_hc)
tb = cbind(node_id = paste0("Node", rownames(tb)), tb, stringsAsFactors = FALSE)
ind = which(tb[, ncol(tb)] == "node")
tb$node_id[ind] = qq("[@{tb$node_id[ind]}](#@{tb$node_id[ind]})", collapse = FALSE)
colnames(tb)[ncol(tb)] = ""
kable(tb, row.names = FALSE)
```

### Partition hierarchy

<% max_depth = max_depth(res_hc) -%>

```{r, echo = FALSE, message = FALSE}
t1 = Sys.time()
message(qq("* collecting classifications for each depth (@{max_depth}..2)"), appendLF = FALSE)
```

```{r, results = "asis", echo = FALSE, include = TRUE}
<% for(depth in max_depth:2) { -%>
knitr_add_tab_item('collect_classes(res_hc, depth = <%=depth%>)', 'depth = <%=depth%>', prefix = 'collect-classes-from-hierarchical-partition')
<% } -%>
knitr_insert_tabs()
```

```{r, results = "asis", echo = FALSE, include = TRUE}
<% for(depth in max_depth:2) { -%>
knitr_add_tab_item('get_classes(res_hc, depth = <%=depth%>)', 'depth = <%=depth%>', prefix = 'get-classes-from-hierarchical-partition', show_and_hide = TRUE)
<% } -%>
knitr_insert_tabs()
```


### PCA plot

```{r, echo = FALSE, message = FALSE}
t2 = Sys.time(); message(paste0(", ", gsub("^ +", "", format(t2 - t1)))); t1 = Sys.time()
message(qq("* making PCA plots"), appendLF = FALSE)
```

```{r, results = 'asis', echo = FALSE, include = TRUE}
<% for(depth in max_depth:2) { -%>
knitr_add_tab_item('dimension_reduction(res_hc, depth = <%=depth%>)', 'depth = <%=depth%>', prefix = 'dimension-reduction-by-depth')
<%}-%>
knitr_insert_tabs()
```

Or you can also do it for each parent node:

```{r, results = 'asis', echo = FALSE, include = TRUE}
<% all_parents = setdiff(all_nodes(res_hc), all_leaves(res_hc))
for(p in all_parents) { -%>
knitr_add_tab_item('dimension_reduction(res_hc, parent_node = "<%=p%>")', 'parent_node = "<%=p%>"', prefix = 'dimension-reduction-by-node')
<%}-%>
knitr_insert_tabs()
```

<% if(max_depth >= 2) { %>

### Signature heatmap

Signature genes:

```{r, echo = FALSE, message = FALSE}
t2 = Sys.time(); message(paste0(", ", gsub("^ +", "", format(t2 - t1)))); t1 = Sys.time()
message(qq("* making signature heatmaps"), appendLF = FALSE)
```

```{r hc-signature, results = "hide"}
get_signatures(res_hc)
```

```{r, echo = FALSE, message = FALSE}
t2 = Sys.time(); message(paste0(", ", gsub("^ +", "", format(t2 - t1))));
```

<% } -%>

<% has_known_anno = FALSE
if(!is.null(res_hc@list[['0']]@anno)) { 
has_known_anno = TRUE -%>

### Test to known annotations

Test correlation between subgroups and known annotations:

```{r, echo = FALSE, message = FALSE}
message(qq("* testing correlation of subgroups to known annotations"))
```

```{r, results = 'asis', echo = FALSE, include = TRUE}
<% for(depth in max_depth:2) { -%>
knitr_add_tab_item('test_to_known_factors(res_hc, depth = <%=depth%>)', 'depth = <%=depth%>', prefix = 'test-to-known-factors-from-hierarchical-partition')
<%}-%>
knitr_insert_tabs()
```


<% } -%>

## Results for each node

<% 
is_hc = TRUE
fs = 2
all_k = res_hc@list[[1]]@k
all_parents = setdiff(all_nodes(res_hc), all_leaves(res_hc))
n_section = length(all_parents)
i_section = 0
frag_list = lapply(seq_along(all_parents), function(ind) {
	i_section = ind
	node = all_parents[ind]
	top_value_method = res_hc[[node]]@top_value_method
	partition_method = res_hc[[node]]@partition_method
	brew(file.path(TEMPLATE_DIR, "section_template.Rmd-template"))
})

for(i in seq_along(frag_list)) { -%>
    <% frag_list[[i]] %>
<% } -%>


## Session info

```{r}
sessionInfo()
```


```{r, echo = FALSE, message = FALSE}
message("-----------------------------------------------------------------")
```

